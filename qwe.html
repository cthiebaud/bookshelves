<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monochromatic Score</title>
    <!-- Include D3.js -->
    <script type="module">
        import * as d3 from 'https://cdn.skypack.dev/d3@7.0.0'

        import regression from 'https://cdn.jsdelivr.net/npm/regression@latest/+esm'

        function rgbToLab(rgb) {
            // Convert RGB to Lab
            var r = rgb[0] / 255.0;
            var g = rgb[1] / 255.0;
            var b = rgb[2] / 255.0;

            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

            r *= 100.0;
            g *= 100.0;
            b *= 100.0;

            var x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
            var y = r * 0.2126729 + g * 0.7151522 + b * 0.0721750;
            var z = r * 0.0193339 + g * 0.1191920 + b * 0.9503041;

            x = x / 95.047;
            y = y / 100.000;
            z = z / 108.883;

            x = x > 0.008856 ? Math.pow(x, 1.0 / 3.0) : (903.3 * x + 16.0) / 116.0;
            y = y > 0.008856 ? Math.pow(y, 1.0 / 3.0) : (903.3 * y + 16.0) / 116.0;
            z = z > 0.008856 ? Math.pow(z, 1.0 / 3.0) : (903.3 * z + 16.0) / 116.0;

            var l = (116.0 * y) - 16.0;
            var a = (x - y) * 500.0;
            var b = (y - z) * 200.0;

            return [l, a, b];
        }

        function labToRgb(lab) {
            // Convert Lab to RGB
            var y = (lab[0] + 16.0) / 116.0;
            var x = lab[1] / 500.0 + y;
            var z = y - lab[2] / 200.0;

            y = Math.pow(y, 3.0) > 0.008856 ? Math.pow(y, 3.0) : (y - 16.0 / 116.0) / 7.787;
            x = Math.pow(x, 3.0) > 0.008856 ? Math.pow(x, 3.0) : (x - 16.0 / 116.0) / 7.787;
            z = Math.pow(z, 3.0) > 0.008856 ? Math.pow(z, 3.0) : (z - 16.0 / 116.0) / 7.787;

            var r = x * 95.047;
            var g = y * 100.000;
            var b = z * 108.883;

            r = r > 0.0031308 ? (1.055 * Math.pow(r, 1.0 / 2.4) - 0.055) : r * 12.92;
            g = g > 0.0031308 ? (1.055 * Math.pow(g, 1.0 / 2.4) - 0.055) : g * 12.92;
            b = b > 0.0031308 ? (1.055 * Math.pow(b, 1.0 / 2.4) - 0.055) : b * 12.92;

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function computeMonochromaticScore(rgbArray) {
            // Apply weights to Lab channels
            var labArray = rgbArray.map(rgb => rgbToLab(rgb));
            labArray.forEach(lab => lab[0] *= 0.5);  // Lightness channel weight

            // Extract x and y values
            var xValues = labArray.map(point => point[0]);
            var yValues = labArray.map(point => point[1]);

            // Fit a linear regression
            var result = regression.linear([xValues, yValues]);

            // Access the coefficients of the linear regression
            var coefficients = result.equation;

            // Use the coefficients as needed

            // Calculate the least squares error
            var mse = meanSquaredError(labArray, coefficients);

            // Define a threshold for monochromatic score
            var threshold = 0.0001;  // You may need to adjust this based on your specific use case

            // Determine the monochromatic score
            var monochromaticScore = mse < threshold ? "Monochromatic" : "Colorful";

            console.log("Monochromatic Score:", monochromaticScore);
            console.log("Mean Squared Error:", mse);

            // Return the results
            return {
                monochromaticScore: monochromaticScore,
                mse: mse
            };
        }

        function meanSquaredError(labArray, coefficients) {
            // Predicted y values based on linear regression
            var predictedYValues = labArray.map(point => coefficients[0] + coefficients[1] * point[0]);

            // Calculate mean squared error
            var sumSquaredDifferences = 0;
            for (var i = 0; i < labArray.length; i++) {
                var diff = labArray[i][1] - predictedYValues[i];
                sumSquaredDifferences += diff * diff;
            }

            return sumSquaredDifferences / labArray.length;
        }

        function createHistogram(data) {
            var margin = { top: 20, right: 30, bottom: 30, left: 40 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("body").append("div")
                .attr("id", "histogram")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // X axis: scale and draw:
            var x = d3.scaleLinear()
                .domain([d3.min(data), d3.max(data)])  // This is what is written on the Axis: from 0 to 100
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // set the parameters for the histogram
            var histogram = d3.histogram()
                .value(function (d) { return d; })   // I need to give the vector of value
                .domain(x.domain())  // then the domain of the graphic
                .thresholds(x.ticks(30)); // then the numbers of bins

            // And apply twice this function to data to get the bins.
            var bins = histogram(data);

            // Y axis: scale and draw:
            var y = d3.scaleLinear()
                .range([height, 0]);
            y.domain([0, d3.max(bins, function (d) { return d.length; })]);   // d3.hist has to be called before the Y axis obviously
            svg.append("g")
                .call(d3.axisLeft(y));

            // append the bar rectangles to the svg element
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", 1)
                .attr("transform", function (d) { return "translate(" + x(d.x0) + "," + y(d.length) + ")"; })
                .attr("width", function (d) { return x(d.x1) - x(d.x0) - 1; })
                .attr("height", function (d) { return height - y(d.length); })
                .style("fill", "#69b3a2");
        }

        function createRGBScatterPlot(rgbArray) {
            var margin = { top: 20, right: 30, bottom: 30, left: 40 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("body").append("div")
                .attr("id", "scatterPlot")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // X axis
            var x = d3.scaleLinear()
                .domain([0, 255])
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // Y axis
            var y = d3.scaleLinear()
                .domain([0, 255])
                .range([height, 0]);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Z axis
            var z = d3.scaleLinear()
                .domain([0, 255])
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisLeft(z));

            // Create scatter plot points
            svg.selectAll("dot")
                .data(rgbArray)
                .enter()
                .append("circle")
                .attr("cx", function (d) { return x(d[0]); })
                .attr("cy", function (d) { return y(d[1]); })
                .attr("cz", function (d) { return z(d[2]); })
                .attr("r", 2)
                .style("fill", "#69b3a2");
        }


        window.handleImageUpload = function () {
            var input = document.getElementById('imageInput');
            var img = document.getElementById('selectedImage');

            var reader = new FileReader();

            reader.onload = function (e) {
                img.src = e.target.result;

                img.onload = function () {
                    // Get the pixel data from the image
                    var canvas = document.createElement('canvas');
                    var ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    var imageData = ctx.getImageData(0, 0, img.width, img.height);

                    // Convert pixel data to Lab array
                    var labArray = [];
                    for (var i = 0; i < imageData.data.length; i += 4) {
                        var rgb = [imageData.data[i], imageData.data[i + 1], imageData.data[i + 2]];
                        var lab = rgbToLab(rgb);
                        labArray.push(lab[1]);  // Use only the 'a' channel for the histogram
                    }

                    // Compute monochromatic score
                    var result = computeMonochromaticScore(labArray);
                    console.log("Monochromatic Score:", result.monochromaticScore);
                    console.log("Mean Squared Error:", result.mse);

                    // Create histogram
                    createHistogram(labArray);

                    // Convert pixel data to RGB array
                    var rgbArray = [];
                    for (var i = 0; i < imageData.data.length; i += 4) {
                        var rgb = [imageData.data[i], imageData.data[i + 1], imageData.data[i + 2]];
                        rgbArray.push(rgb);
                    }

                    // Compute monochromatic score
                    var result = computeMonochromaticScore(rgbArray);
                    console.log("Monochromatic Score:", result.monochromaticScore);
                    console.log("Mean Squared Error:", result.mse);

                    // Create 3D scatter plot
                    createRGBScatterPlot(rgbArray);
                };
            };

            // Read the selected image file
            reader.readAsDataURL(input.files[0]);
        }
    </script>
</head>

<body>
    <input type="file" id="imageInput" onchange="handleImageUpload()">
    <br>
    <img id="selectedImage" style="max-width: 300px; margin-top: 10px;">
</body>

</html>
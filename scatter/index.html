<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Scatter Plot from Image</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@latest/dist/css/bootstrap.min.css">
    <style>
        /*
            + leftCol - - - - - - - - + - - - - - - - -rightCol +
            |                         |                         |
            |                         |                         |
            |                         |                         |
            |              + img1- - +|+ img2- - +              |
            |              |         ||          |              |
            |              |         ||          |              |
            |              + - - - - +|+ - - - - +              |
            + - - - - - - - - - - - - + - - - - - - - - - - - - +

            + leftCol - - - - - - - - +
            |                         |
            |                         |
            |                         |
            |              + img1- - +|
            |              |         ||
            |              |         ||
            |              + - - - - +|
            + - - - - - - - - - - - - +
            + - - - - - - - -rightCol +
            |              + img2- - +|
            |              |         ||
            |              |         ||
            |              + - - - - +|
            |                         |
            |                         |
            |                         |
            + - - - - - - - - - - - - +
        */
        body {
            margin: 0;
            background-color: #f0f0f0;
        }

        .leftCol {
            position: relative;
            align-items: flex-start;
        }

        .rightCol {
            position: relative;
            align-items: flex-end;
        }

        .graph-container {
            position: relative;
            flex: 1;
            width: 80%;
            margin-top: .2rem;
            margin-bottom: .2rem;
            display: block !important;
        }

        .leftCol .graph-container {
            margin-left: 0;
            margin-right: auto;
        }

        .rightCol .graph-container {
            margin-left: auto;
            margin-right: 0;
        }

        .graph {
            width: 100%;
            height: 100%;
        }

        .image-overlay {
            position: absolute;
            margin: 0.5rem;
            width: 25%;
            height: 80%;
            bottom: 0;
            background-repeat: no-repeat;
            background-position: bottom;
            background-size: contain;
        }

        .rightCol .image-overlay {
            left: 0;
        }

        .leftCol .image-overlay {
            right: 0;
        }

        @media (max-width: 1200px) {
            .rightCol .image-overlay {
                top: 0;
                right: 0;
                bottom: auto;
                left: auto;
                background-position: top;
            }

            .rightCol .graph-container {
                margin-left: 0;
                margin-right: auto;
            }

            .graph-container {
                display: inline-block !important;
            }

        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: auto;
            z-index: 20;
        }
    </style>

</head>

<body>

    <div id="loading">
        <svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 473.068 473.068">
            <path
                d="M355.507 181.955c8.793-6.139 29.39-20.519 29.39-55.351v-71.77h9.814c4.49 0 8.17-3.679 8.17-8.169v-38.5c0-4.49-3.681-8.165-8.17-8.165H78.351c-4.495 0-8.165 3.675-8.165 8.165v38.5c0 4.491 3.67 8.169 8.165 8.169h9.82v73.071c0 34.499 10.502 42.576 29.074 53.89l80.745 49.203v20.984c-20.346 12.23-73.465 44.242-80.434 49.107-8.793 6.135-29.384 20.51-29.384 55.352v61.793h-9.82c-4.495 0-8.165 3.676-8.165 8.166v38.498c0 4.49 3.67 8.17 8.165 8.17h316.361c4.49 0 8.17-3.68 8.17-8.17V426.4c0-4.49-3.681-8.166-8.17-8.166h-9.814V355.13c0-34.493-10.508-42.572-29.069-53.885l-80.745-49.202v-20.987c20.332-12.225 73.452-44.234 80.422-49.101zm-102.781 90.904 87.802 53.5c6.734 4.109 10.333 6.373 12.001 9.002 1.991 3.164 2.963 9.627 2.963 19.768v63.104H117.574V356.44c0-19.507 9.718-26.289 16.81-31.242 5.551-3.865 54.402-33.389 85.878-52.289a14.701 14.701 0 0 0 7.135-12.611v-37.563c0-5.123-2.671-9.883-7.053-12.55l-87.54-53.339-.265-.165c-6.741-4.105-10.336-6.369-11.998-9.009-1.992-3.156-2.968-9.626-2.968-19.767v-73.07h237.918v71.77c0 19.5-9.718 26.288-16.814 31.235-5.546 3.872-54.391 33.395-85.869 52.295a14.7 14.7 0 0 0-7.134 12.601v37.563a14.71 14.71 0 0 0 7.052 12.56z" />
            <path
                d="M331.065 154.234s5.291-4.619-2.801-3.299c-19.178 3.115-53.079 15.133-92.079 15.133s-57-11-82.507-11.303c-5.569-.066-5.456 3.629.937 7.391 6.386 3.758 63.772 35.681 71.671 40.08 7.896 4.389 12.417 4.05 20.786 0 12.174-5.902 83.993-48.002 83.993-48.002zm-176.754 243.33c-6.748 6.209-9.978 10.713 5.536 10.713h155.442c16.099 0 9.856-5.453 2.311-12.643-14.576-13.883-45.416-23.566-82.414-23.566-38.754 0-65.844 11.655-80.875 25.496z" />
        </svg>
    </div>

    <div class="container-xl">
        <div class="row">
            <div id="error-msg" class="text-danger col"></div>
        </div>
    </div>

    <!-- Add a central div for drag and drop -->
    <div id="drop-zone" class="text-center" style="display: none; height: 80vh;">
        <div class="d-flex align-items-center justify-content-center h-100 w-100">
            <div>
                <h3>Drag & Drop an Image Here</h3>
                <p>or</p>
                <input type="file" id="file-input" accept="image/*">
            </div>
        </div>
    </div>

    <div class="container-xl">

        <div id="menu" class="row mt-3" style="white-space: nowrap;">
            <style>
                button.btn {
                    padding: 4px 6px;
                    vertical-align: middle !important;
                }

                button.slideshowButton:disabled {
                    color: #a0a0a0;
                }

                button.slideshowButton+span.triangle:after {
                    color: #808080;
                    padding: 4px 6px;
                    vertical-align: middle !important;
                }

                button.slideshowButton:not(:disabled)+.triangle:after {
                    content: '▶';
                }

                button.slideshowButton:disabled+.triangle:after {
                    content: '▷';
                    color: #a0a0a0;
                }
            </style>
            <div class="col" id="menu-bar" style="visibility: hidden; white-space: nowrap;">
                <div class="btn-group" role="group">
                    <button class="btn btn-light" onclick="window.location.href = '/'">
                        <!-- home-svgrepo-com.svg -->
                        <svg fill="#000000" width="800px" height="800px" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" style="width:22px; height:auto;">
                            <path fill-rule="evenodd" fill="#606060"
                                d="M192,1.42108547e-14 L384,153.6 L384,384 L213.333333,384 L213.333333,277.333333 L170.666667,277.333333 L170.666667,384 L1.42108547e-14,384 L1.42108547e-14,153.6 L192,1.42108547e-14 Z M192,53.3333333 L42.6666667,170.666667 L42.6666667,341.333333 L128,341.333333 L128,234.666667 L256,234.666667 L256,341.333333 L341.333333,341.333333 L341.333333,170.666667 L192,53.3333333 Z"
                                transform="translate(64 64)" />
                        </svg>
                    </button>
                    <button class="btn btn-light" onclick="restartFromBeginning()">
                        <!-- reset-svgrepo-com.svg -->
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="width:22px; height:auto;">
                            <path fill-rule="evenodd" fill="#606060"
                                d="M426.667 106.667v42.666L358 149.33c36.077 31.659 58.188 77.991 58.146 128.474-.065 78.179-53.242 146.318-129.063 165.376-75.82 19.058-154.895-15.838-191.92-84.695C58.142 289.63 72.638 204.42 130.348 151.68a85.333 85.333 0 0 0 33.28 30.507 124.587 124.587 0 0 0-46.294 97.066c1.05 69.942 58.051 126.088 128 126.08 64.072 1.056 118.709-46.195 126.906-109.749 6.124-47.483-15.135-92.74-52.237-118.947L320 256h-42.667V106.667h149.334ZM202.667 64c23.564 0 42.666 19.103 42.666 42.667s-19.102 42.666-42.666 42.666c-23.564 0-42.667-19.102-42.667-42.666C160 83.103 179.103 64 202.667 64Z" />
                        </svg>
                    </button>
                </div>
                <span>&nbsp;</span>
                <button id="sb1" class="btn btn-light slideshowButton">show plot</button>
                <span class="triangle"></span>
                <button id="sb2" class="btn btn-light slideshowButton position-relative">show regression plane
                    <span id="std_dev_badge" class="position-absolute top-0 start-50 translate-middle badge rounded-pill text-bg-secondary font-monospace"
                        style="visibility: hidden;">
                        <span id="std_dev" title="Standard Deviation"></span>
                        <span class="visually-hidden">standard deviation</span>
                    </span>
                </button>
                <span class="triangle"></span>
                <button id="sb3" class="btn btn-light slideshowButton">show flat plot</button>
                <span class="triangle"></span>
                <button id="sb4" class="btn btn-light slideshowButton">show flat image</button>
            </div>
        </div>

        <div class="row">
            <!-- First Column -->
            <div class="col-xl-6 leftCol">
                &nbsp;
                <div class="graph-container align-middle">
                    <!-- Plotly Graph -->
                    <div class="graph" id="scatter-plot-container">
                        <div id="scatter-plot"></div>
                    </div>
                </div>
                <!-- Image in the bottom-right corner -->
                <div id="image-display" class="image-overlay"></div>
            </div>

            <!-- Second Column -->
            <div class="col-xl-6 rightCol justify-content-end ">
                &nbsp;
                <div class="graph-container align-middle">
                    <!-- Plotly Graph -->
                    <div class="graph" id="scatter-plot2-container">
                        <div id="scatter-plot2"></div>
                    </div>
                </div>
                <!-- Image in the bottom-left corner -->
                <div id="generated-image" class="image-overlay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/plotly.js@latest/dist/plotly.min.js"></script>
    <script type="module">
        import { Mutex } from 'https://cdn.jsdelivr.net/npm/async-mutex@0.4.0/+esm'

        import _ from './utilities.js'
        import { extractPlaneInfo , orthographicProjectionSet } from './geometry.js'
        import glob from './globals.js'
        import SlideShow from './slideshow.js'

        // gros sablier au milieu
        const loadingElement = document.getElementById('loading')

        // what's in the URL ?
        const queryParams = new URLSearchParams(window.location.search)
        const imagePathFromQueryString = queryParams.get('image')
        const slideshowFromQueryString = ((slideshowParam) => {
            if (typeof slideshowParam === undefined || slideshowParam == null) {
                return true
            } else if (slideshowParam.toLowerCase() === "true" || slideshowParam === "") {
                return true
            }
            return false
        })(queryParams.get('slideshow'))

        // reload the "/scatter" URL
        window.restartFromBeginning = () => {
            window.location.href = `/scatter${slideshowFromQueryString === false ? '?slideshow=false' : ''}`
        }
        // show error message
        window.showError = (errorMsg) => {
            document.getElementById('error-msg').innerHTML = _.truncateString(errorMsg, 160)
            loadingElement.style.display = 'none'
        }
        // clear error message
        window.clearError = () => {
            document.getElementById('error-msg').innerHTML = ''
        }
        // resize the plot when the window is resized
        window.addEventListener('resize', function () {
            Plotly.Plots.resize('scatter-plot')
            Plotly.Plots.resize('scatter-plot2')
        })

        // if the user pushes the "show regression plane" button, 
        // the button will wait until this mutex has been released to display anything
        const regressionPlaneFromServerMutex = new Mutex()

        // function to load the image and create 3D scatter plot with Plotly
        function createScatterPlotFromImage(imagePath) {

            loadingElement.style.display = 'block'

            // cf. new Mutex() comment above
            regressionPlaneFromServerMutex.acquire().then(function (releaseMutex) {
                // initial state of the slideshow
                if (slideshowFromQueryString) {
                    slideShow.bump()
                } else {
                    slideShow.disable()
                }

                // will hold the image
                const theImage = new Image()

                // ouille !
                theImage.onerror = function () {
                    showError(`Error loading image: ${imagePath}`)
                    releaseMutex()
                    loadingElement.style.display = 'none'
                }

                // allons-y
                theImage.onload = function () {

                    const imageDisplay = document.getElementById('image-display')
                    // imageDisplay.src = theImage.src
                    imageDisplay.style.backgroundImage = `url('${theImage.src}')`

                    if (!glob.width || !glob.height) {
                        const containsDimensions = _.contains(theImage, 160 * 300)
                        glob.width = containsDimensions.width
                        glob.height = containsDimensions.height
                    }
                    // just log some calculations
                    console.log(`in memory: ${glob.width}x${glob.height}, squeezed from ${theImage.width}x${theImage.height}`)

                    // create a single canvas element and draw the image once
                    const canvas = document.createElement('canvas')
                    canvas.width = glob.width
                    canvas.height = glob.height
                    const ctx = canvas.getContext('2d', { willReadFrequently: true })
                    ctx.drawImage(this, 0, 0, glob.width, glob.height) // this should be theImage, if I follow correctly

                    // this will hold the points
                    const data3d = {
                        x: [],
                        y: [],
                        z: [],
                        w: [], // the 'a' in rgba
                        mode: 'markers',
                        type: 'scatter3d',
                        showlegend: false,
                        showscale: false,
                        hoverinfo: "none",
                        hovermode: false,
                        marker: {
                            size: 4,
                            color: [],      // array to store colors for each point
                            opacity: 0.80,  // set opacity for every point
                        },
                    }

                    // loop through all pixels and sample pixel data
                    for (let y = 0; y < glob.height; y++) {
                        for (let x = 0; x < glob.width; x++) {
                            // sample pixel data from the drawn image
                            const pixel = ctx.getImageData(x, y, 1, 1).data

                            // add coordinates to the single trace
                            data3d.x.push(pixel[0])  // red component as x
                            data3d.y.push(pixel[1])  // green component as y
                            data3d.z.push(pixel[2])  // blue component as z
                            data3d.w.push(pixel[3] / 255)  // alpha channel

                            // add color for each point
                            data3d.marker.color.push(`rgba(${pixel[0]}, ${pixel[1]}, ${pixel[2]}, ${pixel[3]})`)
                        }
                    }

                    const layout = {
                        scene: {
                            aspectmode: 'cube',
                            xaxis: { autorange: false, showticklabels: false, title: '' },
                            yaxis: { autorange: false, showticklabels: false, title: '' },
                            zaxis: { autorange: false, showticklabels: false, title: '' },
                        },
                        showlegend: false,
                        showscale: false,
                        hoverinfo: "none",
                        hovermode: false,
                        margin: {
                            l: 0,
                            r: 0,
                            t: 0,
                            b: 0
                        }
                    }

                    for (const property in layout.scene) {
                        if (!['xaxis', 'yaxis', 'zaxis'].includes(property)) continue
                        layout.scene[property].range = [glob.MIN, glob.MAX]
                        // leave in case we decide to show tickslabel
                        layout.scene[property]["tickvals"] = [glob.MIN, glob.MAX / 4 - 1, glob.MAX / 2 - 1, 3 * glob.MAX / 4 - 1, glob.MAX - 1]
                        layout.scene[property]["ticktext"] = layout.scene[property]["tickvals"].map(tickval => tickval.toString(16).padStart(2, '0').toUpperCase())
                    }

                    // display the 3D scatter plot
                    Plotly.newPlot('scatter-plot', [data3d], layout, { displayModeBar: false }).then(function () {

                        // if slideshow is active,
                        // it is the good moment, 
                        // from an user perception point of view,
                        // to dismiss the 'loading' visual clue
                        if (slideshowFromQueryString) {
                            loadingElement.style.display = 'none'
                        }

                        // show menu
                        document.getElementById('menu-bar').style.visibility = 'visible'

                        // determine the server location based on the current environment
                        const host = window.location.hostname === 'localhost'
                            ? 'http://localhost:4321'
                            : 'https://bookshelves-406316.ew.r.appspot.com'

                        // fetch the multiple linear regression plane from the server
                        const url = `${host}/perform_regression`
                        fetch(url, {
                            method: 'POST',
                            mode: "cors",
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ x: data3d.x, y: data3d.y, z: data3d.z, image: _.truncateString(imagePath, 128) }),
                        }).then(response => response.json()).then(results => {

                            const regressionPlane = {
                                x: results.meshgrid.x,
                                y: results.meshgrid.y,
                                z: results.meshgrid.z,
                                type: 'surface',
                                opacity: 0.33,
                                colorscale: 'Greys',
                                showlegend: false,
                                showscale: false,
                                hoverinfo: "none",
                                hovermode: false,
                                visible: false,
                                name: 'regression-plane'
                            }

                            Plotly.addTraces('scatter-plot', regressionPlane)
                            releaseMutex()

                            // create a new canvas to draw the generated image
                            const generatedCanvas = document.createElement('canvas')
                            generatedCanvas.width = glob.width
                            generatedCanvas.height = glob.height
                            const generatedCtx = generatedCanvas.getContext('2d', { willReadFrequently: true })

                            // create a new ImageData object to hold the pixel data
                            const imageData = generatedCtx.createImageData(glob.width, glob.height)

                            const planeInfo = extractPlaneInfo(results.coefficients.x, results.coefficients.y, results.coefficients.z, results.coefficients.intercept)

                            // create a second scatter plot with projected and coerced z-coordinates
                            const projectedCoercedScatter = {
                                x: [],
                                y: [],
                                z: [],
                                mode: 'markers',
                                type: 'scatter3d',
                                marker: {
                                    size: 4,
                                    color: [],  // array to store colors for each point
                                    opacity: 0.80,
                                },
                                hoverinfo: 'none'
                            }

                            const projecteds = orthographicProjectionSet(
                                data3d,
                                planeInfo.planeNormal,
                                planeInfo.planePoint
                            )

                            // converts the array of points to separate array for each x, y, z coordinates
                            /*
                            from 
                            [[x1,y1,z1],[x2,y2,z2],...]
                            to
                            {x: [x1,x2,...],y: [y1,y2,...], z:...}
                            */
                            function convertToPointsObject(projecteds) {
                                const transposedProjections = projecteds[0].map((_, i) =>
                                    projecteds.map(projection => projection[i])
                                )

                                return {
                                    x: transposedProjections[0],
                                    y: transposedProjections[1],
                                    z: transposedProjections[2],
                                }
                            }
                            const projectedsAsPoints = convertToPointsObject(projecteds)

                            // coerce projections to [0, 256)
                            projectedCoercedScatter.x = projectedsAsPoints.x.map(x => _.coerce(x))
                            projectedCoercedScatter.y = projectedsAsPoints.y.map(y => _.coerce(y))
                            projectedCoercedScatter.z = projectedsAsPoints.z.map(z => _.coerce(z))

                            // loop through the projectedCoercedScatter data to set the RGB values for each pixel
                            let altered = 0
                            let wrongs = 0
                            for (let i = 0; i < projecteds.length; i++) {

                                const x = projectedCoercedScatter.x[i]
                                const y = projectedCoercedScatter.y[i]
                                const z = projectedCoercedScatter.z[i]
                                const w = data3d.w[i]

                                if (x !== projectedsAsPoints.x[i] ||
                                    y !== projectedsAsPoints.y[i] ||
                                    z !== projectedsAsPoints.z[i]) {
                                    altered++
                                }

                                if (x < 0 || y < 0 || z < 0 || w < 0 || x >= 256 || y >= 256 || z >= 256 || w > 1) {
                                    console.log(`rgba(${x}, ${y}, ${z}, ${w}) WRONG !!!`)
                                    wrongs++
                                }

                                projectedCoercedScatter.marker.color.push(`rgba(${x}, ${y}, ${z}), ${w}`)

                                // calculate the index in the ImageData array
                                const index = i * 4

                                // set the RGB values for the pixel directly from projectedCoercedScatter.z
                                imageData.data[index] = (x)            //  red
                                imageData.data[index + 1] = (y)        //  green
                                imageData.data[index + 2] = (z)        //  blue
                                imageData.data[index + 3] = (w * 255)  // alpha value, 255 for fully opaque
                            }
                            console.log(`altered: ${altered} out of ${projecteds.length}`)
                            console.log(`wrongs: ${wrongs} out of ${projecteds.length}`)
                            document.getElementById('std_dev_badge').style.visibility = 'visible'
                            document.getElementById('std_dev').innerHTML = results.std_dev_residuals.toFixed(2)

                            Plotly.newPlot('scatter-plot2', [projectedCoercedScatter], layout, { displayModeBar: false }).then(function () {
                                // add event listener to plot for changes in the camera angle
                                document.getElementById('scatter-plot2').on('plotly_relayout', function (eventData) {
                                    // check if the event is related to a change in the camera
                                    if (eventData['scene.camera']) {
                                        // update the camera of the othe plot based on the changes in this plot
                                        Plotly.relayout('scatter-plot', {
                                            'scene.camera.eye': eventData['scene.camera'].eye,
                                            'scene.camera.center': eventData['scene.camera'].center,
                                            'scene.camera.up': eventData['scene.camera'].up
                                        })
                                    }
                                })

                                // put the generated pixel data onto the canvas
                                generatedCtx.putImageData(imageData, 0, 0)

                                // set the generated image as the source of the img element
                                const generatedImage = document.getElementById('generated-image')
                                // generatedImage.src = generatedCanvas.toDataURL()
                                generatedImage.style.backgroundImage = `url('${generatedCanvas.toDataURL()}')`
                                
                                // es ist vollbracht
                                loadingElement.style.display = 'none'
                            })
                        }).catch((error) => {
                            console.error('Fetch error:', error)
                            showError(`${error}: ${url}`)
                        }).finally(() => {
                            // ensure the mutex is released regardless of success or failure
                            releaseMutex()
                        })
                    })
                }

                theImage.crossOrigin = "Anonymous"
                theImage.src = imagePath
            })
        }
        
        // slideshow in another file, but largely linked to this one
        const slideShow = new SlideShow(regressionPlaneFromServerMutex)

        // load the image and create the scatter plot when the DOM is ready
        document.addEventListener('DOMContentLoaded', function () {

            const dropZone = document.getElementById('drop-zone')
            const fileInput = document.getElementById('file-input')

            if (imagePathFromQueryString) {
                createScatterPlotFromImage(imagePathFromQueryString)
            } else {
                // show the drop zone if no image parameter is present
                dropZone.style.display = 'flex'
                loadingElement.style.display = 'none'
            }

            function readImageAsDataURLThenFeedIntoScatterPlot(whatEverThatBe) {
                const reader = new FileReader()
                reader.onload = (e) => {
                    const imagePath = e.target.result
                    createScatterPlotFromImage(imagePath)
                    dropZone.style.display = 'none'
                    clearError()
                }
                reader.readAsDataURL(whatEverThatBe)
            }

            function fetchAsBlobThenReadImageAsDataURLThenFeedIntoScatterPlot(item) {
                // check if items array has DataTransferItem objects
                if (item instanceof DataTransferItem) {
                    item.getAsString(url => {
                        // check if the URL is an image URL (you can improve this check based on your requirements)
                        if (url.match(/\.(jpeg|jpg|gif|png|webp)$/) != null) {
                            // fetch the image from the URL
                            fetch(url)
                                .then(response => response.blob())
                                .then(readImageAsDataURLThenFeedIntoScatterPlot)
                                .catch(error => {
                                    const errorMsg = `${error}: ${url}`
                                    showError(errorMsg)
                                    console.error(errorMsg)
                                })
                        } else {
                            const errorMsg = `Not a (jpeg|jpg|gif|png|webp): ${url}`
                            showError(errorMsg)
                            console.error(errorMsg)
                        }
                    })
                }
            }

            // event listener for drag and drop
            dropZone.addEventListener('dragover', function (e) {
                e.preventDefault()
                dropZone.classList.add('bg-light', 'border', 'border-primary')
            })

            dropZone.addEventListener('dragleave', function () {
                dropZone.classList.remove('bg-light', 'border', 'border-primary')
            })

            dropZone.addEventListener('drop', function (e) {
                e.preventDefault()
                dropZone.classList.remove('bg-light', 'border', 'border-primary')
                if (e.dataTransfer.files.length != 0) {
                    readImageAsDataURLThenFeedIntoScatterPlot(e.dataTransfer.files[0])
                } else if (e.dataTransfer.items.length != 0) {
                    fetchAsBlobThenReadImageAsDataURLThenFeedIntoScatterPlot(e.dataTransfer.items[0])
                }
            })

            // event listener for file input change
            fileInput.addEventListener('change', function () {
                if (fileInput.files.length != 0) {
                    readImageAsDataURLThenFeedIntoScatterPlot(fileInput.files[0])
                }
            })
        })

    </script>

</body>

</html>
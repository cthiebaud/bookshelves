<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Scatter Plot from Image</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@latest/dist/css/bootstrap.min.css">
    <style>
        /*
            + leftCol - - - - - - - - + - - - - - - - -rightCol +
            |                         |                         |
            |                         |                         |
            |                         |                         |
            |              + img1- - +|+ img2- - +              |
            |              |         ||          |              |
            |              |         ||          |              |
            |              + - - - - +|+ - - - - +              |
            + - - - - - - - - - - - - + - - - - - - - - - - - - +

            + leftCol - - - - - - - - +
            |                         |
            |                         |
            |                         |
            |              + img1- - +|
            |              |         ||
            |              |         ||
            |              + - - - - +|
            + - - - - - - - - - - - - +
            + - - - - - - - -rightCol +
            |              + img2- - +|
            |              |         ||
            |              |         ||
            |              + - - - - +|
            |                         |
            |                         |
            |                         |
            + - - - - - - - - - - - - +
        */
        body {
            margin: 0;
            background-color: #f0f0f0;
        }

        .leftCol {
            position: relative;
            align-items: flex-start;
        }

        .rightCol {
            position: relative;
            align-items: flex-end;
        }

        .graph-container {
            position: relative;
            flex: 1;
            width: 80%;
            margin-top: .2rem;
            margin-bottom: .2rem;
            display: block !important;
        }

        .leftCol .graph-container {
            margin-left: 0;
            margin-right: auto;
        }

        .rightCol .graph-container {
            margin-left: auto;
            margin-right: 0;
        }

        .graph {
            width: 100%;
            height: 100%;
        }

        .image-overlay {
            position: absolute;
            margin: 0.5rem;
            width: 25%;
            height: 80%;
            bottom: 0;
            background-repeat: no-repeat;
            background-position: bottom;
            background-size: contain;
        }

        .rightCol .image-overlay {
            left: 0;
        }

        .leftCol .image-overlay {
            right: 0;
        }

        @media (max-width: 1200px) {
            .rightCol .image-overlay {
                top: 0;
                right: 0;
                bottom: auto;
                left: auto;
                background-position: top;
            }

            .rightCol .graph-container {
                margin-left: 0;
                margin-right: auto;
            }

            .graph-container {
                display: inline-block !important;
            }

        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: auto;
            z-index: 20;
        }
    </style>

</head>

<body>

    <div id="loading">
        <div class="spinner-border" style="width: 4rem; height: 4rem;" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>

    <div class="container-xl">
        <div class="row">
            <div id="error-msg" class="col text-danger text-center"></div>
        </div>
    </div>

    <!-- Add a central div for drag and drop -->
    <div id="drop-zone" class="text-center" style="display: none; height: 80vh;">
        <div class="d-flex align-items-center justify-content-center h-100 w-100">
            <div>
                <h3>Drag & Drop an Image Here</h3>
                <p>or</p>
                <input type="file" id="file-input" accept="image/*">
            </div>
        </div>
    </div>

    <div class="container-xl">

        <style>
            #menu-bar {
                visibility: hidden;
            }

            #menu-bar button.slideshowButton {
                padding: 4px 6px;
                vertical-align: middle !important;
                white-space: normal !important;
            }

            #menu-bar button.slideshowButton:disabled {
                color: #a0a0a0;
            }

            #menu-bar .slideshowButtonParent {
                white-space: nowrap;
            }

            #menu-bar .slideshowButtonParent:not(.last):after {
                color: #808080;
                padding: 4px 6px;
                vertical-align: middle !important;
            }

            #menu-bar .slideshowButtonParent:not(.last):not(.disabled):after {
                content: '▶';
            }

            #menu-bar .slideshowButtonParent:not(.last).disabled:after {
                content: '▷';
                color: #a0a0a0;
            }
        </style>

        <div id="menu-bar" class="d-flex mt-3 ">
            <!-- slideshow buttons -->
            <div class="nParent">
                <button id="sb1" class="btn btn-light slideshowButton">show plot</button>
            </div>
            <div class="slideshowButtonParent">
                <button id="sb2" class="btn btn-light slideshowButton position-relative">show regression plane
                    <span id="std_dev_badge" class="position-absolute top-0 start-50 translate-middle badge rounded-pill text-bg-secondary font-monospace"
                        style="visibility: hidden;">
                        <span id="std_dev" title="Standard Deviation"></span>
                        <span class="visually-hidden">standard deviation</span>
                    </span>
                </button>
            </div>
            <div class="slideshowButtonParent">
                <button id="sb3" class="btn btn-light slideshowButton">show flat plot</button>
            </div>
            <div class="slideshowButtonParent last">
                <button id="sb4" class="btn btn-light slideshowButton">show flat image</button>
            </div>

            <!-- link to dropzone button -->
            <button class="btn btn-light ms-auto" style="margin-left: 1rem;" onclick="restartFromBeginning()">
                <svg width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width: 22px; height: auto;">
                    <g>
                        <path fill="none" d="M0 0h24v24H0z" />
                        <path fill-rule="nonzero"
                            d="M16 13l6.964 4.062-2.973.85 2.125 3.681-1.732 1-2.125-3.68-2.223 2.15L16 13zm-2-7h2v2h5a1 1 0 0 1 1 1v4h-2v-3H10v10h4v2H9a1 1 0 0 1-1-1v-5H6v-2h2V9a1 1 0 0 1 1-1h5V6zM4 14v2H2v-2h2zm0-4v2H2v-2h2zm0-4v2H2V6h2zm0-4v2H2V2h2zm4 0v2H6V2h2zm4 0v2h-2V2h2zm4 0v2h-2V2h2z" />
                    </g>
                </svg>
            </button>

        </div>

        <div class="row">
            <!-- First Column -->
            <div class="col-xl-6 leftCol">
                &nbsp;
                <div class="graph-container align-middle">
                    <!-- Plotly Graph -->
                    <div class="graph" id="scatter-plot-container">
                        <div id="scatter-plot"></div>
                    </div>
                </div>
                <!-- Image in the bottom-right corner -->
                <div id="image-display" class="image-overlay"></div>
            </div>

            <!-- Second Column -->
            <div class="col-xl-6 rightCol justify-content-end ">
                &nbsp;
                <div class="graph-container align-middle">
                    <!-- Plotly Graph -->
                    <div class="graph" id="scatter-plot2-container">
                        <div id="scatter-plot2"></div>
                    </div>
                </div>
                <!-- Image in the bottom-left corner -->
                <div id="generated-image" class="image-overlay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/plotly.js@latest/dist/plotly.min.js"></script>
    <script type="module">
        import { Mutex } from 'https://cdn.jsdelivr.net/npm/async-mutex@0.4.0/+esm'

        import _ from './utilities.js'
        import { extractPlaneInfo, orthographicProjectionSet } from './geometry.js'
        import glob from './globals.js'
        import SlideShow from './slideshow.js'

        // gros sablier au milieu
        const loadingElement = document.getElementById('loading')

        // what's in the URL ?
        const queryParams = new URLSearchParams(window.location.search)
        const imagePathFromQueryString = queryParams.get('image')
        const slideshowFromQueryString = ((slideshowParam) => {
            if (typeof slideshowParam === undefined || slideshowParam == null) {
                return true
            } else if (slideshowParam.toLowerCase() === "true" || slideshowParam === "") {
                return true
            }
            return false
        })(queryParams.get('slideshow'))

        // reload the "/scatter" URL
        window.restartFromBeginning = () => {
            window.location.href = `/scatter${slideshowFromQueryString === false ? '?slideshow=false' : ''}`
        }
        // show error message
        window.showError = (errorMsg) => {
            document.getElementById('error-msg').innerHTML = _.truncateString(errorMsg, 160)
            loadingElement.style.display = 'none'
        }
        // clear error message
        window.clearError = () => {
            document.getElementById('error-msg').innerHTML = ''
        }
        // resize the plot when the window is resized
        window.addEventListener('resize', function () {
            Plotly.Plots.resize('scatter-plot')
            Plotly.Plots.resize('scatter-plot2')
        })

        // if the user pushes the "show regression plane" button, 
        // the button will wait until this mutex has been released to display anything
        const regressionPlaneFromServerMutex = new Mutex()

        async function awaitRegressionPlane() {
            await regressionPlaneFromServerMutex.waitForUnlock()
        }
        async function showSurface() {
            const scatterPlot = document.getElementById('scatter-plot')
            const allTraces = scatterPlot.data

            // find index of trace-object where "name" property is "regression-plane":
            const regressionPlane = allTraces.findIndex(obj => obj.name === 'regression-plane')

            // make specified trace visible to the user:
            await Plotly.restyle(scatterPlot, { "visible": true }, [regressionPlane])
        }

        // function to load the image and create 3D scatter plot with Plotly
        function createScatterPlotFromImage(imagePath) {

            loadingElement.style.display = 'block'

            // cf. new Mutex() comment above
            regressionPlaneFromServerMutex.acquire().then(function (releaseMutex) {
                // initial state of the slideshow
                if (slideshowFromQueryString) {
                    slideShow.bump()
                } else {
                    slideShow.disable()
                }

                // will hold the image
                const theImage = new Image()

                // ouille !
                theImage.onerror = function () {
                    showError(`Error loading image: ${imagePath}`)
                    releaseMutex()
                    loadingElement.style.display = 'none'
                }

                // allons-y
                theImage.onload = function () {

                    const imageDisplay = document.getElementById('image-display')
                    // imageDisplay.src = theImage.src
                    imageDisplay.style.backgroundImage = `url('${theImage.src}')`

                    if (!glob.width || !glob.height) {
                        const containsDimensions = _.contains(theImage, 160 * 300)
                        glob.width = containsDimensions.width
                        glob.height = containsDimensions.height
                    }
                    // just log some calculations
                    console.log(`in memory: ${glob.width}x${glob.height}, squeezed from ${theImage.width}x${theImage.height}`)

                    // create a single canvas element and draw the image once
                    const canvas = document.createElement('canvas')
                    canvas.width = glob.width
                    canvas.height = glob.height
                    const ctx = canvas.getContext('2d', { willReadFrequently: true })
                    ctx.drawImage(this, 0, 0, glob.width, glob.height) // this should be theImage, if I follow correctly

                    // this will hold the points
                    const data3d = {
                        x: [],
                        y: [],
                        z: [],
                        w: [], // the 'a' in rgba
                        mode: 'markers',
                        type: 'scatter3d',
                        showlegend: false,
                        showscale: false,
                        hoverinfo: "none",
                        hovermode: false,
                        marker: {
                            size: 4,
                            color: [],      // array to store colors for each point
                            opacity: 0.80,  // set opacity for every point
                        },
                    }

                    // loop through all pixels and sample pixel data
                    for (let y = 0; y < glob.height; y++) {
                        for (let x = 0; x < glob.width; x++) {
                            // sample pixel data from the drawn image
                            const pixel = ctx.getImageData(x, y, 1, 1).data

                            // add coordinates to the single trace
                            data3d.x.push(pixel[0])  // red component as x
                            data3d.y.push(pixel[1])  // green component as y
                            data3d.z.push(pixel[2])  // blue component as z
                            data3d.w.push(pixel[3] / 255)  // alpha channel

                            // add color for each point
                            data3d.marker.color.push(`rgba(${pixel[0]}, ${pixel[1]}, ${pixel[2]}, ${pixel[3]})`)
                        }
                    }

                    const layout = {
                        scene: {
                            aspectmode: 'cube',
                            xaxis: { autorange: false, showticklabels: false, title: '' },
                            yaxis: { autorange: false, showticklabels: false, title: '' },
                            zaxis: { autorange: false, showticklabels: false, title: '' },
                        },
                        showlegend: false,
                        showscale: false,
                        hoverinfo: "none",
                        hovermode: false,
                        margin: {
                            l: 0,
                            r: 0,
                            t: 0,
                            b: 0
                        }
                    }

                    for (const property in layout.scene) {
                        if (!['xaxis', 'yaxis', 'zaxis'].includes(property)) continue
                        layout.scene[property].range = [glob.MIN, glob.MAX]
                        // leave in case we decide to show tickslabel
                        layout.scene[property]["tickvals"] = [glob.MIN, glob.MAX / 4 - 1, glob.MAX / 2 - 1, 3 * glob.MAX / 4 - 1, glob.MAX - 1]
                        layout.scene[property]["ticktext"] = layout.scene[property]["tickvals"].map(tickval => tickval.toString(16).padStart(2, '0').toUpperCase())
                    }

                    // display the 3D scatter plot
                    Plotly.newPlot('scatter-plot', [data3d], layout, { displayModeBar: false }).then(function () {

                        // if slideshow is active,
                        // it is the good moment, 
                        // from an user perception point of view,
                        // to dismiss the 'loading' visual clue
                        if (slideshowFromQueryString) {
                            loadingElement.style.display = 'none'
                        }

                        // show menu
                        document.getElementById('menu-bar').style.visibility = 'visible'

                        // determine the server location based on the current environment
                        const host = window.location.hostname === 'localhost'
                            ? 'http://localhost:4321'
                            : 'https://bookshelves-406316.ew.r.appspot.com'

                        // fetch the multiple linear regression plane from the server
                        const url = `${host}/perform_regression`
                        fetch(url, {
                            method: 'POST',
                            mode: "cors",
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ x: data3d.x, y: data3d.y, z: data3d.z, image: _.truncateString(imagePath, 128) }),
                        }).then(response => {
                            console.log("HABEMUS regression")
                            return response.json()
                        }).then(results => {

                            const regressionPlane = {
                                x: results.meshgrid.x,
                                y: results.meshgrid.y,
                                z: results.meshgrid.z,
                                type: 'surface',
                                opacity: 0.33,
                                colorscale: 'Greys',
                                showlegend: false,
                                showscale: false,
                                hoverinfo: "none",
                                hovermode: false,
                                visible: false,
                                name: 'regression-plane'
                            }

                            Plotly.addTraces('scatter-plot', regressionPlane).then(() => {
                                console.log("About to release Mutex ...")
                                releaseMutex()
                                console.log("Mutex released !")
                                if (!slideshowFromQueryString) {
                                    showSurface()
                                }
                            })

                            // create a new canvas to draw the generated image
                            const generatedCanvas = document.createElement('canvas')
                            generatedCanvas.width = glob.width
                            generatedCanvas.height = glob.height
                            const generatedCtx = generatedCanvas.getContext('2d', { willReadFrequently: true })

                            // create a new ImageData object to hold the pixel data
                            const imageData = generatedCtx.createImageData(glob.width, glob.height)

                            const planeInfo = extractPlaneInfo(results.coefficients.x, results.coefficients.y, results.coefficients.z, results.coefficients.intercept)

                            // create a second scatter plot with projected and coerced z-coordinates
                            const projectedCoercedScatter = {
                                x: [],
                                y: [],
                                z: [],
                                mode: 'markers',
                                type: 'scatter3d',
                                marker: {
                                    size: 4,
                                    color: [],  // array to store colors for each point
                                    opacity: 0.80,
                                },
                                hoverinfo: 'none'
                            }

                            const projecteds = orthographicProjectionSet(
                                data3d,
                                planeInfo.planeNormal,
                                planeInfo.planePoint
                            )

                            // converts the array of points to separate array for each x, y, z coordinates
                            /*
                            from 
                            [[x1,y1,z1],[x2,y2,z2],...]
                            to
                            {x: [x1,x2,...],y: [y1,y2,...], z:...}
                            */
                            function convertToPointsObject(projecteds) {
                                const transposedProjections = projecteds[0].map((_, i) =>
                                    projecteds.map(projection => projection[i])
                                )

                                return {
                                    x: transposedProjections[0],
                                    y: transposedProjections[1],
                                    z: transposedProjections[2],
                                }
                            }
                            const projectedsAsPoints = convertToPointsObject(projecteds)

                            // coerce projections to [0, 256)
                            projectedCoercedScatter.x = projectedsAsPoints.x.map(x => _.coerce(x))
                            projectedCoercedScatter.y = projectedsAsPoints.y.map(y => _.coerce(y))
                            projectedCoercedScatter.z = projectedsAsPoints.z.map(z => _.coerce(z))

                            // loop through the projectedCoercedScatter data to set the RGB values for each pixel
                            let altered = 0
                            let wrongs = 0
                            for (let i = 0; i < projecteds.length; i++) {

                                const x = projectedCoercedScatter.x[i]
                                const y = projectedCoercedScatter.y[i]
                                const z = projectedCoercedScatter.z[i]
                                const w = data3d.w[i]

                                if (x !== projectedsAsPoints.x[i] ||
                                    y !== projectedsAsPoints.y[i] ||
                                    z !== projectedsAsPoints.z[i]) {
                                    altered++
                                }

                                if (x < 0 || y < 0 || z < 0 || w < 0 || x >= 256 || y >= 256 || z >= 256 || w > 1) {
                                    console.log(`rgba(${x}, ${y}, ${z}, ${w}) WRONG !!!`)
                                    wrongs++
                                }

                                projectedCoercedScatter.marker.color.push(`rgba(${x}, ${y}, ${z}), ${w}`)

                                // calculate the index in the ImageData array
                                const index = i * 4

                                // set the RGB values for the pixel directly from projectedCoercedScatter.z
                                imageData.data[index] = (x)            //  red
                                imageData.data[index + 1] = (y)        //  green
                                imageData.data[index + 2] = (z)        //  blue
                                imageData.data[index + 3] = (w * 255)  // alpha value, 255 for fully opaque
                            }
                            console.log(`altered: ${altered} out of ${projecteds.length}`)
                            console.log(`wrongs: ${wrongs} out of ${projecteds.length}`)
                            document.getElementById('std_dev_badge').style.visibility = 'visible'
                            document.getElementById('std_dev').innerHTML = results.std_dev_residuals.toFixed(2)

                            Plotly.newPlot('scatter-plot2', [projectedCoercedScatter], layout, { displayModeBar: false }).then(function () {
                                // add event listener to plot for changes in the camera angle
                                document.getElementById('scatter-plot2').on('plotly_relayout', function (eventData) {
                                    // check if the event is related to a change in the camera
                                    if (eventData['scene.camera']) {
                                        // update the camera of the othe plot based on the changes in this plot
                                        Plotly.relayout('scatter-plot', {
                                            'scene.camera.eye': eventData['scene.camera'].eye,
                                            'scene.camera.center': eventData['scene.camera'].center,
                                            'scene.camera.up': eventData['scene.camera'].up
                                        })
                                    }
                                })

                                // put the generated pixel data onto the canvas
                                generatedCtx.putImageData(imageData, 0, 0)

                                // set the generated image as the source of the img element
                                const generatedImage = document.getElementById('generated-image')
                                // generatedImage.src = generatedCanvas.toDataURL()
                                generatedImage.style.backgroundImage = `url('${generatedCanvas.toDataURL()}')`

                                // es ist vollbracht
                                loadingElement.style.display = 'none'
                            })
                        }).catch((error) => {
                            console.error('Fetch error:', error)
                            showError(`${error}: ${url}`)
                        }).finally(() => {
                            // ensure the mutex is released regardless of success or failure
                            releaseMutex()
                        })
                    })
                }

                theImage.crossOrigin = "Anonymous"
                theImage.src = imagePath
            })
        }

        // slideshow in another file, but largely linked to this one
        const slideShow = new SlideShow([null, awaitRegressionPlane, showSurface, null, null])

        // load the image and create the scatter plot when the DOM is ready
        document.addEventListener('DOMContentLoaded', function () {

            const dropZone = document.getElementById('drop-zone')
            const fileInput = document.getElementById('file-input')

            if (imagePathFromQueryString) {
                createScatterPlotFromImage(imagePathFromQueryString)
            } else {
                // show the drop zone if no image parameter is present
                dropZone.style.display = 'flex'
                loadingElement.style.display = 'none'
            }

            function readImageAsDataURLThenFeedIntoScatterPlot(whatEverThatBe) {
                const reader = new FileReader()
                reader.onload = (e) => {
                    const imagePath = e.target.result
                    createScatterPlotFromImage(imagePath)
                    dropZone.style.display = 'none'
                    clearError()
                }
                reader.readAsDataURL(whatEverThatBe)
            }

            function fetchAsBlobThenReadImageAsDataURLThenFeedIntoScatterPlot(item) {
                // check if items array has DataTransferItem objects
                if (item instanceof DataTransferItem) {
                    item.getAsString(url => {
                        // check if the URL is an image URL (you can improve this check based on your requirements)
                        if (url.match(/\.(jpeg|jpg|gif|png|webp)$/) != null) {
                            // fetch the image from the URL
                            fetch(url)
                                .then(response => response.blob())
                                .then(readImageAsDataURLThenFeedIntoScatterPlot)
                                .catch(error => {
                                    const errorMsg = `${error}: ${url}`
                                    showError(errorMsg)
                                    console.error(errorMsg)
                                })
                        } else {
                            const errorMsg = `Not a (jpeg|jpg|gif|png|webp): ${url}`
                            showError(errorMsg)
                            console.error(errorMsg)
                        }
                    })
                }
            }

            // event listener for drag and drop
            dropZone.addEventListener('dragover', function (e) {
                e.preventDefault()
                dropZone.classList.add('bg-light', 'border', 'border-primary')
            })

            dropZone.addEventListener('dragleave', function () {
                dropZone.classList.remove('bg-light', 'border', 'border-primary')
            })

            dropZone.addEventListener('drop', function (e) {
                e.preventDefault()
                dropZone.classList.remove('bg-light', 'border', 'border-primary')
                if (e.dataTransfer.files.length != 0) {
                    readImageAsDataURLThenFeedIntoScatterPlot(e.dataTransfer.files[0])
                } else if (e.dataTransfer.items.length != 0) {
                    fetchAsBlobThenReadImageAsDataURLThenFeedIntoScatterPlot(e.dataTransfer.items[0])
                }
            })

            // event listener for file input change
            fileInput.addEventListener('change', function () {
                if (fileInput.files.length != 0) {
                    readImageAsDataURLThenFeedIntoScatterPlot(fileInput.files[0])
                }
            })
        })

    </script>

</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    -->
    <title>3D Scatter Plot from Image</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@latest/dist/css/bootstrap.min.css">
    <style>
        /*
            + leftCol - - - - - - - - + - - - - - - - -rightCol +
            |                         |                         |
            |                         |                         |
            |                         |                         |
            |              + img1- - +|+ img2- - +              |
            |              |         ||          |              |
            |              |         ||          |              |
            |              + - - - - +|+ - - - - +              |
            + - - - - - - - - - - - - + - - - - - - - - - - - - +

            + leftCol - - - - - - - - +
            |                         |
            |                         |
            |                         |
            |              + img1- - +|
            |              |         ||
            |              |         ||
            |              + - - - - +|
            + - - - - - - - - - - - - +
            + - - - - - - - -rightCol +
            |              + img2- - +|
            |              |         ||
            |              |         ||
            |              + - - - - +|
            |                         |
            |                         |
            |                         |
            + - - - - - - - - - - - - +
        */
        body {
            margin: 0;

            background-color: #ececec;
        }

        .leftCol {
            position: relative;
            align-items: flex-start;
            border-right: .5px dotted gray;
        }

        .rightCol {
            position: relative;
            align-items: flex-end;
            border-left: .5px dotted gray;
        }

        .graph-container {
            position: relative;
            flex: 1;
            width: 80%;
        }

        .leftCol .graph-container {
            margin-left: 0;
            margin-right: auto;
        }

        .rightCol .graph-container {
            margin-left: auto;
            margin-right: 0;
        }

        .graph {
            width: 100%;
            height: 100%;
        }

        .image-overlay {
            position: absolute;
            margin: 0.5rem;
            width: 25%;
            height: auto;
            bottom: 0;
        }

        .image-overlay-left {
            left: 0;
        }

        .image-overlay-right {
            right: 0;
        }

        @media (max-width: 1140px) {
            .image-overlay-left {
                bottom: auto;
                top: 0;
                right: 0;
                left: auto;
            }

            .image-overlay-right {}

            .rightCol .graph-container {
                margin-left: 0;
                margin-right: auto;
            }
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            z-index: 12;
        }
    </style>

</head>

<body>

    <div id="loading">
        <svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 473.068 473.068">
            <path
                d="M355.507 181.955c8.793-6.139 29.39-20.519 29.39-55.351v-71.77h9.814c4.49 0 8.17-3.679 8.17-8.169v-38.5c0-4.49-3.681-8.165-8.17-8.165H78.351c-4.495 0-8.165 3.675-8.165 8.165v38.5c0 4.491 3.67 8.169 8.165 8.169h9.82v73.071c0 34.499 10.502 42.576 29.074 53.89l80.745 49.203v20.984c-20.346 12.23-73.465 44.242-80.434 49.107-8.793 6.135-29.384 20.51-29.384 55.352v61.793h-9.82c-4.495 0-8.165 3.676-8.165 8.166v38.498c0 4.49 3.67 8.17 8.165 8.17h316.361c4.49 0 8.17-3.68 8.17-8.17V426.4c0-4.49-3.681-8.166-8.17-8.166h-9.814V355.13c0-34.493-10.508-42.572-29.069-53.885l-80.745-49.202v-20.987c20.332-12.225 73.452-44.234 80.422-49.101zm-102.781 90.904 87.802 53.5c6.734 4.109 10.333 6.373 12.001 9.002 1.991 3.164 2.963 9.627 2.963 19.768v63.104H117.574V356.44c0-19.507 9.718-26.289 16.81-31.242 5.551-3.865 54.402-33.389 85.878-52.289a14.701 14.701 0 0 0 7.135-12.611v-37.563c0-5.123-2.671-9.883-7.053-12.55l-87.54-53.339-.265-.165c-6.741-4.105-10.336-6.369-11.998-9.009-1.992-3.156-2.968-9.626-2.968-19.767v-73.07h237.918v71.77c0 19.5-9.718 26.288-16.814 31.235-5.546 3.872-54.391 33.395-85.869 52.295a14.7 14.7 0 0 0-7.134 12.601v37.563a14.71 14.71 0 0 0 7.052 12.56z" />
            <path
                d="M331.065 154.234s5.291-4.619-2.801-3.299c-19.178 3.115-53.079 15.133-92.079 15.133s-57-11-82.507-11.303c-5.569-.066-5.456 3.629.937 7.391 6.386 3.758 63.772 35.681 71.671 40.08 7.896 4.389 12.417 4.05 20.786 0 12.174-5.902 83.993-48.002 83.993-48.002zm-176.754 243.33c-6.748 6.209-9.978 10.713 5.536 10.713h155.442c16.099 0 9.856-5.453 2.311-12.643-14.576-13.883-45.416-23.566-82.414-23.566-38.754 0-65.844 11.655-80.875 25.496z" />
        </svg>
    </div>

    <!-- Add a central div for drag and drop -->
    <div id="drop-zone" class="text-center" style="display: none; height: 80vh;">
        <div class="d-flex align-items-center justify-content-center h-100 w-100">
            <div>
                <h3>Drag & Drop an Image Here</h3>
                <p>or</p>
                <input type="file" id="file-input" accept="image/*">
            </div>
        </div>
    </div>

    <div class="container-xl">
        <div id="menu" class="row mt-3" style="white-space: nowrap;">
            <style>
                .advance {
                    visibility: hidden;
                }

                .advance.visible {
                    visibility: visible;
                }

                .gray {
                    color: #a0a0a0;
                    /* Set the color to black */
                }

                button:disabled {
                    filter: opacity(0.75);
                }
            </style>
            <div class="col" id="menu-bar" style="visibility: hidden; white-space: nowrap;">
                <button class="btn btn-light" onclick="restartFromBeginning()">
                    <span class="gray">↺</span>
                </button>
                <span class="gray">|</span>
                <button id="advance-button-1" class="btn btn-light advance">show plot</button>
                <span class="gray">▶</span>
                <button id="advance-button-2" class="btn btn-light advance position-relative">
                    show regression plane
                    <span id="std_dev_badge" class="position-absolute top-0 start-50 translate-middle badge rounded-pill text-bg-secondary font-monospace"
                        style="visibility: hidden;">
                        <span id="std_dev" title="Standard Deviation"></span>
                        <span class="visually-hidden">Standard Deviation</span>
                    </span>
                </button>
                <span class="gray">▶</span>
                <button id="advance-button-3" class="btn btn-light advance">show flat plot</button>
                <span class="gray">▶</span>
                <button id="advance-button-4" class="btn btn-light advance">show flat image</button>
            </div>
            <div class="col-auto d-flex align-items-center">
                <div id="error-msg" class="text-danger"></div>
            </div>
        </div>

        <div class="row">
            <!-- First Column -->
            <div id="leftCol1" class="col-xl-6 leftCol">
                &nbsp;
                <div class="graph-container">
                    <!-- Plotly Graph -->
                    <div class="graph" id="scatter-plot-container">
                        <div id="scatter-plot"></div>
                    </div>
                </div>
                <!-- Image in the top-right corner -->
                <a href="/"><img id="image-display" class="image-overlay image-overlay-right" /></a>
            </div>

            <!-- Second Column -->
            <div id="rightCol1" class="col-xl-6 justify-content-end rightCol">
                &nbsp;
                <div class="graph-container">
                    <!-- Plotly Graph -->
                    <div class="graph" id="scatter-plot2-container">
                        <div id="scatter-plot2"></div>
                    </div>
                </div>
                <!-- Image in the top-left corner -->
                <img id="generated-image" class="image-overlay image-overlay-left" />
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/plotly.js@latest/dist/plotly.min.js"></script>
    <script type="module">
        import { Mutex } from 'https://cdn.jsdelivr.net/npm/async-mutex@0.4.0/+esm'

        import { orthographicProjectionSet } from './vectorOperations.js';
        import { extractPlaneInfo } from './planeOperations.js';
        import glob from './singletonModule.js';
        import _ from './_.js'

        const queryParams = new URLSearchParams(window.location.search);
        const imagePathFromQueryString = queryParams.get('image');
        const slideshowFromQueryString = ((slideshowFromQueryString) => {
            if (typeof slideshowFromQueryString === undefined || slideshowFromQueryString == null) {
                return true;
            } else if (slideshowFromQueryString.toLowerCase() === "true") {
                return true;
            }
            return false;
        })(queryParams.get('slideshow'));


        window.restartFromBeginning = () => {
            // Reload the "/scatter" URL
            window.location.href = `/scatter${slideshowFromQueryString === false ? '?slideshow=false' : ''}`
        }

        // if the user pushes the "show regression plane" button, 
        // the button will wait until this mutex has been released to display anything
        const regressionPlaneFromServerMutex = new Mutex();

        const advanceButtons = Array.from(document.getElementsByClassName('advance'))

        // Function to load the image and create 3D scatter plot with Plotly
        function createScatterPlotFromImage(imagePath) {
            const loadingElement = document.getElementById('loading');
            const imageDisplay = document.getElementById('image-display');

            regressionPlaneFromServerMutex.acquire().then(function (releaseMutex) {
                // Initial state of the slideshow
                if (slideshowFromQueryString) {
                    currentStep = updateSlideShow(currentStep);
                } else {
                    advanceButtons.map((element, index) => updateSlideShow(index))
                }
                const theImage = new Image()

                theImage.onerror = function () {
                    document.getElementById('error-msg').innerHTML = `Error loading the image: ${_.truncateString(imagePath, 24)}`
                    releaseMutex()
                };

                theImage.onload = function () {

                    imageDisplay.onload = function () {
                        console.log(`in memory dimensions: ${glob.width}x${glob.height}, squeezed from ${theImage.width}x${theImage.height}, instead of <img>: ${imageDisplay.width}x${imageDisplay.height}`)
                    }
                    imageDisplay.src = theImage.src

                    if (!glob.width || !glob.height) {
                        const containsDimensions = _.contains(theImage, 150*300)
                        glob.width = containsDimensions.width;
                        glob.height = containsDimensions.height;
                    }

                    // Create a single canvas element and draw the image once
                    const canvas = document.createElement('canvas');
                    canvas.width = glob.width;
                    canvas.height = glob.height;
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    ctx.drawImage(this, 0, 0, glob.width, glob.height);

                    const data3d = {
                        x: [],
                        y: [],
                        z: [],
                        mode: 'markers',
                        type: 'scatter3d',
                        showlegend: false,
                        showscale: false,
                        hoverinfo: "none",
                        hovermode: false,
                        marker: {
                            size: 4,
                            color: [],      // Array to store colors for each point
                            opacity: 0.80,  // Set opacity for every point
                        },
                    };

                    // Loop through all pixels and sample pixel data
                    for (let y = 0; y < glob.height; y++) {
                        for (let x = 0; x < glob.width; x++) {
                            // Sample pixel data from the drawn image
                            const pixel = ctx.getImageData(x, y, 1, 1).data;

                            // Add coordinates to the single trace
                            data3d.x.push(pixel[0]);  // Red component as x
                            data3d.y.push(pixel[1]);  // Green component as y
                            data3d.z.push(pixel[2]);  // Blue component as z

                            // Add color for each point
                            data3d.marker.color.push(`rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`);
                        }
                    }

                    const layout = {
                        scene: {
                            aspectmode: 'cube',
                            xaxis: { autorange: false, showticklabels: false, title: '' },
                            yaxis: { autorange: false, showticklabels: false, title: '' },
                            zaxis: { autorange: false, showticklabels: false, title: '' },
                        },
                        showlegend: false,
                        showscale: false,
                        hoverinfo: "none",
                        hovermode: false,
                        margin: {
                            l: 0,
                            r: 0,
                            t: 0,
                            b: 0
                        }
                    };

                    for (const property in layout.scene) {
                        if (!['xaxis', 'yaxis', 'zaxis'].includes(property)) continue;
                        layout.scene[property].range = [glob.MIN, glob.MAX]
                        layout.scene[property]["tickvals"] = [glob.MIN, glob.MAX / 4 - 1, glob.MAX / 2 - 1, 3 * glob.MAX / 4 - 1, glob.MAX - 1]
                        layout.scene[property]["ticktext"] = layout.scene[property]["tickvals"].map(tickval => tickval.toString(16).padStart(2, '0').toUpperCase())
                    }

                    // Display the 3D scatter plot
                    Plotly.newPlot('scatter-plot', [data3d], layout, { displayModeBar: false }).then(function () {

                        loadingElement.style.display = 'none'
                        document.getElementById('menu-bar').style.visibility = 'visible'
                        advanceButtons.forEach((e) => e.classList.add('visible'))

                        // Determine the server location based on the current environment
                        const host = window.location.hostname === 'localhost'
                            ? 'http://localhost:4321'
                            : 'https://bookshelves-406316.ew.r.appspot.com';

                        // Fetch the multiple linear regression plane from the server
                        const url = `${host}/perform_regression`
                        fetch(url, {
                            method: 'POST',
                            mode: "cors",
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ x: data3d.x, y: data3d.y, z: data3d.z, image: _.truncateString(imagePath, 128) }),
                        }).then(response => response.json()).then(results => {

                            const regressionPlane = {
                                x: results.meshgrid.x,
                                y: results.meshgrid.y,
                                z: results.meshgrid.z,
                                type: 'surface',
                                opacity: 0.33,
                                colorscale: 'Greys',
                                showlegend: false,
                                showscale: false,
                                hoverinfo: "none",
                                hovermode: false,
                                visible: false,
                                name: 'regression-plane'
                            };

                            Plotly.addTraces('scatter-plot', regressionPlane);
                            releaseMutex()

                            // Create a new canvas to draw the generated image
                            const generatedCanvas = document.createElement('canvas');
                            generatedCanvas.width = glob.width;
                            generatedCanvas.height = glob.height;
                            const generatedCtx = generatedCanvas.getContext('2d', { willReadFrequently: true });

                            // Create a new ImageData object to hold the pixel data
                            const imageData = generatedCtx.createImageData(glob.width, glob.height);

                            const planeInfo = extractPlaneInfo(results.coefficients.x, results.coefficients.y, results.coefficients.z, results.coefficients.intercept)

                            // Create a second scatter plot with projected and coerced z-coordinates
                            const projectedCoercedScatter = {
                                x: [],
                                y: [],
                                z: [],
                                mode: 'markers',
                                type: 'scatter3d',
                                marker: {
                                    size: 4,
                                    color: [],  // Array to store colors for each point
                                    opacity: 0.80,
                                },
                                hoverinfo: 'none'
                            };

                            const projecteds = orthographicProjectionSet(
                                data3d,
                                planeInfo.planeNormal,
                                planeInfo.planePoint
                            )

                            // converts the array of points to separate array for each x, y, z coordinates
                            /*
                            from 
                            [[x1,y1,z1],[x2,y2,z2],...]
                            to
                            {x: [x1,x2,...],y: [y1,y2,...], z:...}
                            */
                            function convertToPointsObject(projecteds) {
                                const transposedProjections = projecteds[0].map((_, i) =>
                                    projecteds.map(projection => projection[i])
                                );

                                return {
                                    x: transposedProjections[0],
                                    y: transposedProjections[1],
                                    z: transposedProjections[2]
                                };
                            }
                            const projectedsAsPoints = convertToPointsObject(projecteds);

                            // coerce projections to [0, 256)
                            projectedCoercedScatter.x = projectedsAsPoints.x.map(x => _.coerce(x))
                            projectedCoercedScatter.y = projectedsAsPoints.y.map(y => _.coerce(y))
                            projectedCoercedScatter.z = projectedsAsPoints.z.map(z => _.coerce(z))

                            // Loop through the projectedCoercedScatter data to set the RGB values for each pixel
                            let altered = 0
                            let wrongs = 0
                            for (let i = 0; i < projecteds.length; i++) {

                                const x = projectedCoercedScatter.x[i]
                                const y = projectedCoercedScatter.y[i]
                                const z = projectedCoercedScatter.z[i]

                                if (x !== projectedsAsPoints.x[i] ||
                                    y !== projectedsAsPoints.y[i] ||
                                    z !== projectedsAsPoints.z[i]) {
                                    /*
                                    console.log(`rgb(${projectedsAsPoints.x[i]}, ${projectedsAsPoints.y[i]}, ${projectedsAsPoints.z[i]}) ORIGINAL...`)
                                    console.log(`rgb(${x}, ${y}, ${z}) ...ALTERED !!!`)
                                    */
                                    altered++
                                }

                                if (x < 0 || y < 0 || z < 0 || x >= 256 || y >= 256 || z >= 256) {
                                    console.log(`rgb(${x}, ${y}, ${z}) WRONG !!!`)
                                    wrongs++
                                }

                                projectedCoercedScatter.marker.color.push(`rgb(${x}, ${y}, ${z})`);

                                // Calculate the index in the ImageData array
                                const index = i * 4;

                                // Set the RGB values for the pixel directly from projectedCoercedScatter.z
                                imageData.data[index] = (x)        //  & 0xFF; // Red
                                imageData.data[index + 1] = (y)    //  & 0xFF; // Green
                                imageData.data[index + 2] = (z)    //  & 0xFF; // Blue
                                imageData.data[index + 3] = 255; // Alpha value, 255 for fully opaque
                            }
                            console.log(`altered: ${altered} out of ${projecteds.length}`)
                            console.log(`wrongs: ${wrongs} out of ${projecteds.length}`)
                            document.getElementById('std_dev_badge').style.visibility = 'visible'
                            document.getElementById('std_dev').innerHTML = results.std_dev_residuals.toFixed(2)

                            Plotly.newPlot('scatter-plot2', [projectedCoercedScatter], layout, { displayModeBar: false }).then(function () {
                                /* const plot2SvgContainer = document.querySelector('#scatter-plot2 .svg-container');
     
                                // Apply custom styles to right-align the canvas
                                plot2SvgContainer.style.marginLeft = 'auto';
                                plot2SvgContainer.style.marginRight = '0';
                                */
                                // Add event listener to plot1 for changes in the camera angle
                                document.getElementById('scatter-plot2').on('plotly_relayout', function (eventData) {
                                    // Check if the event is related to a change in the camera
                                    if (eventData['scene.camera']) {
                                        // Update the camera of plot2 based on the changes in plot1
                                        Plotly.relayout('scatter-plot', {
                                            'scene.camera.eye': eventData['scene.camera'].eye,
                                            'scene.camera.center': eventData['scene.camera'].center,
                                            'scene.camera.up': eventData['scene.camera'].up
                                        });
                                    }
                                });

                                // Put the generated pixel data onto the canvas
                                generatedCtx.putImageData(imageData, 0, 0);

                                // Set the generated image as the source of the img element
                                const generatedImage = document.getElementById('generated-image');
                                generatedImage.src = generatedCanvas.toDataURL();
                            })
                        }).catch((error) => {
                            console.error('Fetch error:', error);
                            document.getElementById('error-msg').innerHTML = `${_.truncateString(url, 24)}: ${error}`
                        }).finally(() => {
                            // Ensure the mutex is released regardless of success or failure
                            releaseMutex();
                        });
                    })
                }

                theImage.crossOrigin = "Anonymous";
                theImage.src = imagePath
            })
        }

        // Function to show or hide elements based on the current step
        function updateAdvanceButtons(step) {
            advanceButtons.forEach(b => {
                b.disabled = true
                b.classList.remove('btn-secondary')
                b.classList.add('btn-light')
            })
            if (step < advanceButtons.length) {
                const thisButton = advanceButtons[step]
                thisButton.disabled = false
                thisButton.addEventListener('click', handleInteraction)
                thisButton.classList.remove('btn-light')
                thisButton.classList.add('btn-secondary')
            }
        }

        // Function to show or hide elements based on the current step
        let currentStep = 0;
        function updateSlideShow(step) {
            const scatterPlotContainer = document.getElementById('scatter-plot-container');
            const scatterPlot2Container = document.getElementById('scatter-plot2-container');
            const imageLink = document.getElementById('generated-image');

            updateAdvanceButtons(step)

            // Show elements based on the current step
            switch (step) {
                case 0:
                    // Hide all elements 
                    scatterPlotContainer.style.visibility = 'hidden';
                    scatterPlot2Container.style.visibility = 'hidden';
                    imageLink.style.display = 'none';
                    return step + 1;

                case 1:
                    scatterPlotContainer.style.visibility = 'visible';
                    return step + 1;

                case 2:
                    regressionPlaneFromServerMutex
                        .waitForUnlock()
                        .then(() => {
                            const scatterPlot = document.getElementById('scatter-plot');
                            const allTraces = scatterPlot.data;

                            // Find index of trace-object with "name" property = "regression-plane":
                            const regressionPlane = allTraces.findIndex(obj => obj.name === 'regression-plane');

                            // Make specified trace visible to the user:
                            Plotly.restyle(scatterPlot, { "visible": true }, [regressionPlane]);

                            return currentStep = step + 1;
                        });
                    return step;

                case 3:
                    scatterPlot2Container.style.visibility = 'visible';
                    return step + 1;

                case 4:
                    imageLink.style.display = 'block';
                    return step + 1;

                default:
                    return step;
            }
        }

        // Function to handle key events and button click
        function handleInteraction(e) {
            if (event.target.disabled) {
                return
            }
            currentStep = updateSlideShow(currentStep)
        }

        // Attach key event listener to the document
        document.addEventListener('keypress', handleInteraction);

        // Load the image and create the scatter plot when the DOM is ready
        document.addEventListener('DOMContentLoaded', function () {

            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');

            // Show the drop zone if no image parameter is present
            if (imagePathFromQueryString) {
                createScatterPlotFromImage(imagePathFromQueryString);
            } else {
                const loadingElement = document.getElementById('loading');
                dropZone.style.display = 'flex';
                loadingElement.style.display = 'none'
            }

            function handleFiles(files) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const imagePath = e.target.result;
                    createScatterPlotFromImage(imagePath);
                    dropZone.style.display = 'none';
                };

                reader.readAsDataURL(files[0]);
            }
            function handleItems(items) {
                const dropZone = document.getElementById('drop-zone');

                // Check if items array has DataTransferItem objects
                if (items.length > 0 && items[0] instanceof DataTransferItem) {
                    items[0].getAsString(url => {
                        // Check if the URL is an image URL (you can improve this check based on your requirements)
                        if (url.match(/\.(jpeg|jpg|gif|png)$/) != null) {
                            // Fetch the image from the URL
                            fetch(url)
                                .then(response => response.blob())
                                .then(blob => {
                                    const reader = new FileReader();
                                    reader.onload = function (e) {
                                        const imagePath = e.target.result;
                                        createScatterPlotFromImage(imagePath);
                                        dropZone.style.display = 'none';
                                    };
                                    reader.readAsDataURL(blob);
                                })
                                .catch(error => {
                                    document.getElementById('error-msg').innerHTML = `${_.truncateString(url, 24)}: ${error}`
                                    console.error('Error fetching the image:', error);
                                });
                        } else {
                            document.getElementById('error-msg').innerHTML = `${_.truncateString(url, 24)}: Invalid URL or not an image URL.`
                            console.error('Invalid URL or not an image URL.');
                        }
                    });
                }
            }

            // Event listener for drag and drop
            dropZone.addEventListener('dragover', function (e) {
                e.preventDefault();
                dropZone.classList.add('bg-light', 'border', 'border-primary');
            });

            dropZone.addEventListener('dragleave', function () {
                dropZone.classList.remove('bg-light', 'border', 'border-primary');
            });

            dropZone.addEventListener('drop', function (e) {
                e.preventDefault();
                dropZone.classList.remove('bg-light', 'border', 'border-primary');
                if (e.dataTransfer.files.length != 0) {
                    handleFiles(e.dataTransfer.files);
                } else if (e.dataTransfer.items.length != 0) {
                    handleItems(e.dataTransfer.items);
                }
            });

            // Event listener for file input change
            fileInput.addEventListener('change', function () {
                handleFiles(fileInput.files);
            });
        });


        // Resize the plot when the window is resized
        window.addEventListener('resize', function () {
            Plotly.Plots.resize('scatter-plot');
            Plotly.Plots.resize('scatter-plot2');
        });
    </script>

</body>

</html>
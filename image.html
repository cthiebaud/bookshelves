<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monochromatic Score</title>
    <!-- Include D3.js -->
    <script type="module">
        import * as d3 from 'https://cdn.skypack.dev/d3@7.0.0'
        import colorSpace from 'https://cdn.jsdelivr.net/npm/color-space@latest/+esm'
        import regression from 'https://cdn.jsdelivr.net/npm/regression@latest/+esm'


        function computeMonochromaticScore(labArray) {
            // Apply weights to Lab channels
            // var labArray = rgbArray.map(rgb => colorSpace.rgb.lab(rgb));
            // const lab = colorSpace.rgb.lab(color.color)

            // labArray.forEach(lab => lab[0] *= 0.5);  // Lightness channel weight

            // Extract x and y values
            var xValues = labArray.map(point => point[0]);
            var yValues = labArray.map(point => point[1]);

            // Fit a linear regression
            var result = regression.linear([xValues, yValues]);

            // Access the coefficients of the linear regression
            var coefficients = result.equation;

            // Use the coefficients as needed

            // Calculate the least squares error
            var mse = meanSquaredError(labArray, coefficients);

            // Define a threshold for monochromatic score
            var threshold = 0.0001;  // You may need to adjust this based on your specific use case

            // Determine the monochromatic score
            var monochromaticScore = mse < threshold ? "Monochromatic" : "Colorful";

            console.log("Monochromatic Score:", monochromaticScore);
            console.log("Mean Squared Error:", mse);

            // Return the results
            return {
                monochromaticScore: monochromaticScore,
                mse: mse
            };
        }

        function meanSquaredError(labArray, coefficients) {
            // Predicted y values based on linear regression
            var predictedYValues = labArray.map(point => coefficients[0] + coefficients[1] * point[0]);

            // Calculate mean squared error
            var sumSquaredDifferences = 0;
            for (var i = 0; i < labArray.length; i++) {
                var diff = labArray[i][1] - predictedYValues[i];
                sumSquaredDifferences += diff * diff;
            }

            return sumSquaredDifferences / labArray.length;
        }

        function createHistogram(data) {
            var margin = { top: 20, right: 30, bottom: 30, left: 40 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("body").append("div")
                .attr("id", "histogram")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // X axis: scale and draw:
            var x = d3.scaleLinear()
                .domain([d3.min(data), d3.max(data)])  // This is what is written on the Axis: from 0 to 100
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // set the parameters for the histogram
            var histogram = d3.histogram()
                .value(function (d) { return d; })   // I need to give the vector of value
                .domain(x.domain())  // then the domain of the graphic
                .thresholds(x.ticks(30)); // then the numbers of bins

            // And apply twice this function to data to get the bins.
            var bins = histogram(data);

            // Y axis: scale and draw:
            var y = d3.scaleLinear()
                .range([height, 0]);
            y.domain([0, d3.max(bins, function (d) { return d.length; })]);   // d3.hist has to be called before the Y axis obviously
            svg.append("g")
                .call(d3.axisLeft(y));

            // append the bar rectangles to the svg element
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", 1)
                .attr("transform", function (d) { return "translate(" + x(d.x0) + "," + y(d.length) + ")"; })
                .attr("width", function (d) { return x(d.x1) - x(d.x0) - 1; })
                .attr("height", function (d) { return height - y(d.length); })
                .style("fill", "#69b3a2");
        }

        function createRGBScatterPlot(rgbArray) {
            var margin = { top: 20, right: 30, bottom: 30, left: 40 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("body").append("div")
                .attr("id", "scatterPlot")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            var scene = svg.append("scene")

            scene.append("orthoviewpoint")
                .attr("centerOfRotation", [5, 5, 5])
                .attr("fieldOfView", [-5, -5, 15, 15])
                .attr("orientation", [-0.5, 1, 0.2, 1.12 * Math.PI / 4])
                .attr("position", [8, 4, 15])

            // X axis
            var x = d3.scaleLinear()
                .domain([0, 255])
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // Y axis
            var y = d3.scaleLinear()
                .domain([0, 255])
                .range([height, 0]);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Z axis
            var z = d3.scaleLinear()
                .domain([0, 255])
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisLeft(z));

            // Create scatter plot points
            svg.selectAll("dot")
                .data(rgbArray)
                .enter()
                .append("circle")
                .attr("cx", function (d) { return x(d[0]); })
                .attr("cy", function (d) { return y(d[1]); })
                .attr("cz", function (d) { return z(d[2]); })
                .attr("r", 2)
                .style("fill", "#69b3a2");
        }


        window.handleImageUpload = function () {
            var params = new URLSearchParams(window.location.search);
            var imageUrl = params.get('image');

            if (imageUrl) {
                var img = document.getElementById('selectedImage');

                img.src = imageUrl;

                // Wait for the image to fully load
                img.addEventListener('load', function () {
                    // Get the pixel data from the image
                    var canvas = document.createElement('canvas');
                    var ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    var imageData = ctx.getImageData(0, 0, img.width, img.height);

                    // Convert pixel data to Lab array
                    var labArray = [];
                    for (var i = 0; i < imageData.data.length; i += 4) {
                        var rgb = [imageData.data[i], imageData.data[i + 1], imageData.data[i + 2]];
                        var lab = colorSpace.rgb.lab(rgb);

                        labArray.push(lab[1]); // Use only the 'a' channel for the histogram
                    }

                    // Compute monochromatic score
                    var result = computeMonochromaticScore(labArray);
                    console.log("Monochromatic Score:", result.monochromaticScore);
                    console.log("Mean Squared Error:", result.mse);

                    // Create histogram
                    createHistogram(labArray);

                    // Convert pixel data to RGB array
                    var rgbArray = [];
                    for (var i = 0; i < imageData.data.length; i += 4) {
                        var rgb = [imageData.data[i], imageData.data[i + 1], imageData.data[i + 2]];
                        rgbArray.push(rgb);
                    }

                    // Compute monochromatic score
                    var result = computeMonochromaticScore(rgbArray);
                    console.log("Monochromatic Score:", result.monochromaticScore);
                    console.log("Mean Squared Error:", result.mse);

                    // Create 3D scatter plot
                    createRGBScatterPlot(rgbArray);
                });
            } else {
                console.error("Image URL not provided in the query string.");
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            // Call handleImageUpload on document load
            window.handleImageUpload();
        });
    </script>
</head>

<body>
    <img id="selectedImage" style="max-width: 300px; margin-top: 10px;">
</body>

</html>